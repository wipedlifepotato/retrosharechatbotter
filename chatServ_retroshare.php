<?php
error_reporting(0);
class curl_c{
    const DEFPREURL='/api/v2/';

    function fix_mPreurl(){
		$this->mPreurl=self::DEFPREURL;
    }
    function set_mPreurl($val){
	$this->mPreurl=$val;
    }


    function __construct($url,$port){
     $this->fix_mPreurl();
     $this->url=$url;
     $this->port=$port;
     
    }
    function curl_do($name, $arguments, $preurl=false,$POST=1 ){
	if ( $preurl == false) $preurl=$this->mPreurl;
        if (sizeof($arguments) < 1)return False;
        $name=str_replace("__","/",$name);
        $this->ch = curl_init();
	curl_setopt($this->ch, CURLOPT_CONNECTTIMEOUT, 10);
	curl_setopt($this->ch, CURLOPT_HTTPHEADER, array('Accept: application/json'));
	//print($this->url.$preurl."$name");
        curl_setopt($this->ch, CURLOPT_URL, $this->url.$preurl."$name");
        curl_setopt($this->ch, CURLOPT_PORT, $this->port);
        curl_setopt($this->ch, CURLOPT_HEADER, 1); 
        curl_setopt($this->ch, CURLOPT_POST, $POST);
        curl_setopt($this->ch, CURLOPT_VERBOSE, 1);
        curl_setopt($this->ch, CURLOPT_RETURNTRANSFER, true);
        if ( gettype($arguments[0]) == "string" ){ 
         $buf="";
         for ($i=0;$i<sizeof($arguments);$i++)
            $buf.=$arguments[$i];
         curl_setopt($this->ch, CURLOPT_POSTFIELDS, $buf);
         curl_setopt($this->ch, CURLOPT_HTTPHEADER, array('Content-type: application/json', 'Content-length: '.strlen($buf)));

        }else{
            $encoded=json_encode($arguments[0]);
            curl_setopt($this->ch, CURLOPT_POSTFIELDS, $encoded );
            curl_setopt($this->ch, CURLOPT_HTTPHEADER, array('Content-type: application/json', 'Content-length: '.strlen($encoded)));
        }
        $res = curl_exec($this->ch);
	$hs=curl_getinfo($this->ch, CURLINFO_HEADER_SIZE);
	$header = substr($res, 0, $hs);
	$res = substr($res, $hs);
        curl_close($this->ch);
        //print($res);
        return $res;
    }
    function __call($name, $arguments) {
	return $this->curl_do($name, $arguments);
    }

    function gjson($buf){
/*$pattern = '
/
\{              # { character
    (?:         # non-capturing group
        [^{}]   # anything that is not a { or }
        |       # OR
        (?R)    # recurses the entire pattern
    )*          # previous group zero or more times
\}              # } character
/x
';
        $matches=array();
        preg_match_all($pattern, $buf, $matches);
        
        $match=$matches[0][0];
        print_r($matches);
	print("\r\n----\r\n");
*/
//	print_r($buf);

        return json_decode($buf,true);
    }
}

class chatServ{
    
    function __construct($ip="127.0.0.1",$port="9090"){
     $this->curl=new curl_c($ip,$port);
    }
    function get_cert($cert){
    
/*
        (
            [is_hidden_node] => 1
            [last_contact] => 0
            [location] => My computer
            [name] => Livingstone (Generated by RetroShare) <>
            [nodeType] => TOR
            [peer_id] => a8507363a8a0f660d4b3faac71737477
            [pgp_id] => 9F0B3BD579E39D19
            [state_string] => undefined
        )

*/
        $cert_json=array(
            'cert_string'=>$cert
        );
        $res=$this->curl->gjson(
            $this->curl->peers__examine_cert
            (
                $cert_json)
            );
        if ($res['returncode'] == 'fail')
            return False;
        return $res;
         
    }
    function check_cert($cert){
        if ($this->get_cert($cert) != False) return True;
        return False;
    }
    
    /*
    http://127.0.0.1:9090/api/v2/peers
    --data-binary '{"cert_string":"$cert","flags":{"allow_direct_download":false,"allow_push":false,"require_whitelist":false}}'
    */
    function add_peer($cert,$direct_download=True){
            if( !$this->check_cert($cert) ) return False;
            $cert_json=array(
                'cert_string'=>$cert,
                'flags'=>array(
                    'allow_direct_download'=>$direct_download,
                    'require_whitelist'=>false
                )
            );
            $res=$this->curl->gjson(
                $this->curl->peers($cert_json)
            );
            if ($res['returncode'] == 'ok') return True;
	   // print_r($res);
	    $this->addpeer_dbg_msg=$res['debug_msg'];
            return False;
    }
    function readMessage($channel){
	//$this->curl->set_mPreurl("/api/v2/chat");
	$messages=$this->curl->gjson( $this->curl->curl_do("$channel","","/api/v2/chat/messages/",0) );
	//$messages=json_decode($messages,true);
	//print("Messss: \n");
	//print_r($messages);
	return $messages;
	//$this->curl->fix_mPreurl();
    }
    function sendMessage($chatid, $message){
	//{"chat_id":"LA2F5CB25E2CFDA04","msg":"test"}
	$r=array(
		'chat_id'=>$chatid,
		'msg'=>$message
	);
	$ret=$this->curl->gjson($this->curl->chat__send_message($r));
	if ($res['returncode'] == 'ok') return True;
	return False;
    }
    function getLobbies(){
	$ret=$this->curl->gjson($this->curl->chat__lobbies());
	return $ret;
    }
    function clearLobbies(){
	$this->curl->chat__clear_lobby();
    }
}

?>
